/* 
                        指针
附 : 指针的作用
    表示一些复杂的数据结构
    快速的传递数据
    使函数返回一个以上的值
    详细见 文件eg1.c
    能直接访问硬件
    能方便地处理字符串
    是能理解面向对象语言中 引用 的基础




一.基本类型指针(重要)

    1.指针-又名地址, 指针变量-又名存储地址的变量/
    与普通变量不同,指针变量是存储的变量所处的地址,类似住户门牌号
    2.写法
    数据类型  *  变量名称 / 需要注意,指针变量只能存储 定义的数据类型的地址
        如:
            int * p 或者 int* p 或者 int *p
        /  表示这个指针变量只能储存整型变量的地址                
        / 需要注意,该部分表示名为 p 的指针变量,而不是名为 * p 的整型变量
    3.p = &i 的意义
        1) p 保存的 i 的地址,因此 p 指向 i
        2) p 不是 i ,i 也不是 p,所以修改 p ,不影响 i;修改 p ,不影响 i
        3) 如果一个指针指向了某个普通变量,则
            *指针变量  就等同于  普通变量
            如:
                p 为指针变量,并且 p 存放了普通变量的地址,则 p 指向了 i
                所以 *p 就等同于 i
            换言之:  所有出现 *p 的地方全可以替换为 i
                    所有出现 i 的地方全可以替换为 *p
                <*p 就是以 p 的内容为地址的变量>
    




                        附 :   * 的含义
    1.乘法
    2.定义指针变量
        int * p
            定义了一个名为 p 的指针变量 /
            int *表示 p 只能存放一个整型 int 的地址
    3.指针运算符
        该运算符放在已经定义好的指针变量的前面
        如果 p 是一个已经定义好的指针变量
        则      <*p 表示以 p 的内容为地址的变量>





                        附  :  如何通过被调函数修改主调函数的值
    1.实参必须为该普通变量的地址
    2.形参必须为指针变量
    3.在被调函数中通过
            *形参名 = ....
        的方式即可修改主调函数的值




二.指针和数组
    1.指针和一维数组
        1) 一维数组名是个指针常量,它存放的是一维数组的第一个元素的地址

        2) 下标和指针的关系

        3) 指针变量的运算

    2.指针和二维数组
        1) 与二维数组行地址相匹配的指针变量是行指针变量,用与指向一个一维数组 \
        即 行数组
            e.g:
        int a[行][列]
        int (*p)[列] = a;

        则 p 可以访问 a 这个二维数组         
        输出 *(*(p+行)+列) 则就是输出 a[行][列] 的意思
        2) 

三.动态内存的分配
    1.传统数组的缺点
        1) 只能用常量表示数组长度,无法用变量定义

        2) 传统形式定义的数组,该数组的内存程序员法手动释放

        3) 数组长度一旦定义,其长度就不能再更改

        4) 传统方式的数组不能跨函数使用
    2.为什么要使用动态分配内存
        1) 动态数组很好的解决了传统数组的缺点
        2) 传统数组又叫静态数组
    3.动态内存分配举例及动态内存的构造
        1) 具体例子请看eg2文件
        2) 动态构造一维数组
                int len = 5;
                int * pArr;
                pArr = (int *)malloc(4 * len);//则 pArr 指向的就是20个字节的第一个地址 \
                *pArr 表示前四个字节位置的值      //而 pArr +1指向的就是从第5个字节开始的第一个地址 \ 
                *pArr +1表示从第5个字节开始前四个字节位置的值

                实质上pArr = (int *)malloc(4 * len);近似于 int pArr[len];
                即构造了一个动态数组,且每个元素均为 int 类型
            如果想增加 pArr 这个动态数组的元素则需要使用 realloc 函数
            即:
            int LEN = 10;
            int *pArr = realloc(pArr, 4 * LEN)
            则此时的元素数为10个
    4.两者区别
        静态内存:
            1) 静态内存是在系统自动分配并释放
            2) 静态内存是在栈中分配的,即:先进后出,后进先出
        
            |                               |    
            |                               |
            |-------------------------------|
            |       a[],b[]                 |
            |-------------------------------| 
            |          g(int i) ....f(int x)| 
            |-------------------------------|       
            |_______________________________|
            
            压   栈                       ↑ 
               ↓                       出  栈  

            |                               |
            |-------------------------------|                               
            |         int i,intx; ....      |                                          
            |-------------------------------|                                                    
            |       a[],b[] ....            |                                           
            |-------------------------------|                                           
            |          g(int i) ....f(int x)|                                            
            |-------------------------------|                                         
            |_______________________________|      
                
        
        动态内存存储:
            1) 由程序员手动用malloc函数手动分配内存,释放内存
            2) 动态内存是在堆分配的




四.多级指针
    详看eg3









*/
#include <stdio.h>

void exchange2(int * p, int * q){
    int t;                  
    /*
    为什么指针可以?
    指针锁定的a,b的地址,使得指针变量指向a,b /
    那么 p 就会存放 a 的地址, q 就会存放 b 的地址
    而 *p 代表 a 的值,*q代表 b 的值 /
    所以 *p 与 *q 的交换是 a 和 b 的交换  
    */
    t = *p;
    *p = *q;
    *q = t;

    return;
}

void exchange1(int a,int b){
    /* 函数在运行结束后,不会发生数字交换 /
    形参与实参独立,意味着总计有四个变量 /
                
    exchange 运行到return,形参a,b会自动释放内存 /
    即交换的为形参的值,且形参运行后会释放内存并消失 /
    也就不会交换实参的值了 /
    */
    int t;

    t = a;
    a = b;
    b = t;

    return;
}

int main(){

    int a,b;
    int c,d;
    c = 3,d = 5;
    a = 3,b = 5;
    exchange1( a, b);//exchange1无法互换
    exchange2( c, d);//exchange2可以交换
    printf("%d %d", a, b); // exchange1结果为 3, 5

    return 0;
}



























